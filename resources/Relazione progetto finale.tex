\documentclass[a4paper]{article}

%% Language and font encodings
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}

%% Sets page size and margins
\usepackage[a4paper,top=3cm,bottom=2cm,left=2cm,right=2cm,marginparwidth=1.75cm]{geometry}

%% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{array}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{titlesec}

\usepackage{amsmath}

\titlespacing*{\section}
{0pt}{6.5ex plus 1ex minus .2ex}{3.3ex plus .2ex}
\titlespacing*{\subsection}
{0pt}{5ex plus 1ex minus .2ex}{2.5ex plus .2ex}


%===========================================================================
%% Front
%===========================================================================

\title{Proposal for an application}
\author{Lisa Cattalani and Andrea Pari \\
Alma Mater Studiorum - University of Bologna, via Venezia 52 \\
47023 Cesena, Italy \\
\textit{lisa.cattalani@studio.unibo.it, andrea.pari6@studio.unibo.it}}

%===========================================================================


\begin{document}
\maketitle
\newpage 
\tableofcontents
\newpage



%===========================================================================
\section{Introduction}
%===========================================================================

The current report describes the entire software development process adopted to analyze, design and implement a specific software system. The process has been divided into two phases: the first phase concerns the definition of a model of the software system, while the second phase concerns the implementation of the software system carried out after that the product owner has viewed the model.



%===========================================================================
\section{Vision}
%===========================================================================

We want to show how to manage the development of a distributed, heterogeneous and embedded software system by focusing on the analysis and design of the system. The software system at issue will be designed and implemented as an application in the field of \textit{Internet of Things}.



%===========================================================================
\section{Goals}
%===========================================================================

The goal is to build a software system able to evolve from an initial prototype (defined as result of a problem analysis phase) to a final and testable product. This goal will be achieved by working in a team and by "mixing" in a proper (pragmatically useful) way an agile (SCRUM) software development with modeling.



%===========================================================================
\section{Requirements }
%===========================================================================

A differential drive robot (called from now only robot) must reach an area (B) starting from a given point A. To reach the area B, the robot must cross an area equipped with N (N $\geq$ 1) distance sensors (sonars). The signal emitted by each sonar is reflected by a wall put in front of it at a distance of approximately 90 cm.
Moreover:
\begin{itemize}
	\item The section of the wall in front of each sonar is painted with a different illustration.
	\item The robot is equipped with a distance sensor (sonar) and (optionally) with a Web Cam both positioned in its front. It owns also a Led.
	\item The robot should move from A to B by travelling along a straight line, at a distance of approximately 40-50 cm from the base-line of the sonars.
\end{itemize}
Design and build a (prototype of a) software system such that:
\begin{itemize}
	\item Shows the sonar data on the GUI associated to a console running on a conventional PC.
	\item Evaluates the expression
	
	(s\textsubscript{k} + s\textsubscript{k} + 1 + ... s\textsubscript{N}) / (N - k + 1)
	
	where k is the number of the first sensor not reached by the robot and s\textsubscript{k} is the value of the distance currently measured by that sensor. If the value of the expression is less than a prefixed value DMIN (e.g. DMIN = 70), play an alarm sound.
	\item When the robot reaches the area in front of a sonar, it:
	\begin{itemize}
		\item first stops;
		\item then rotates to its left of approximately 90 degrees;
		\item starts blinking a led put on the robot;
		\item takes a photo of the wall (in a simulated way only, if no WebCam is available) and sends the photo to console by using the MQTT protocol;
		\item rotates to its right of approximately 90 degrees to compensate the previous rotation;
		\item stops the blinking of the led and continues its movement towards the area B;
	\end{itemize}
	\item When the robot leaves the area in front to the last sonar, it continues until it arrives at the area B.
	\item Stops the robot movement as soon as possible:
	\begin{itemize}
		\item when an obstacle is detected by the sonar in front of the robot;
		\item when an alarm sound is played;
		\item the user sends to the robot a proper command (e.g. STOP).
	\end{itemize}
	\item Makes it possible to restart the system (by manually repositioning the robot at point A) without restarting the software.
\end{itemize}



%===========================================================================
\section{Requirements analysis }
%===========================================================================

The first step for a correct requirement analysis is to read carefully the requirements text and to create a glossary of terms. The creation of a glossary is crucial in order to understand the applicative domain of the system and to avoid any ambiguity or misunderstanding during the requirements analysis. \newline\newline
The terms are reported in the following table in the order in which they appear into the requirements text. For each terms is shown the related meaning and eventual synonims that appear into the text. \hfill \break

\def\arraystretch{1.8}
\begin{tabular}{ | m{3cm} | m{9cm} | m{3cm} | }

    \hline
    
	\textbf{Term} & \textbf{Definition} & \textbf{Synonyms}\\ 
	
	\hline
	
	\textit{Differential drive robot} & A differential drive robot is a two-wheeled drive robot system with independent actuators for each wheel. The name refers to the fact that the motion vector of the robot is the sum of the independent wheel motions. & Robot\\
	
	\hline
	
	\textit{Distance sensor} & A distance sensor is a device that is able to locate the presence of an object (also called obstacle) in front of it. The sensor estimates the distance from the object by sending waves toward it and by calculating the response time. & Sonar\newline Sensor\\
	
	\hline
	
	\textit{Prototype} & A prototype is an incomplete version of a software system used to demonstrate concepts, to try some project options and to find out problems and possible solutions. A prototype can present all or a few characteristics of the final system. & Model\\
	
	\hline
	
	\textit{GUI} & This term refers to the \textit{Graphical User Interface} associated to the console. Through this interface, the user can view the data sent to the console by the distance sensor of the robot. & Interface\newline User interface\\
	
	\hline
	
	\textit{Console} & In the current context, the console represents the means by which the user and the robot interact with each other. Through the console, the user sends commands to the robot and receives the photos taken by it. & Command panel\\
	
	\hline
	
	\textit{Alarm sound} & The sound emitted by the console when the value calculated through the expression of the distance is under a certain threshold. In particular, the sound is emitted when a sensor on the wall has detected an object in front of itself (then along the path of the robot). & Alarm\\
	
	\hline
	
	\textit{MQTT protocol} & MQTT is the communication protocol through which the robot sends the taken photos to the console. &\\
	
	\hline
	
	\textit{Obstacle} & This term denotes any type of object detected by the sonar of the robot that prevents the robot itself to reach the area B. & \\
	
	\hline
	
	\textit{User} & The user is the one who will use the software system, giving commands to the robot through the console and receiving the photos taken by it. & End user\\
	
	\hline
	
	\textit{Command} & A command is an order given from the user to the robot through the console. Two commands are allowed: STOP (through the console) to stop the movement of the robot, RESTART (manually) to reposition the robot at a given point A. &\\
	
	\hline
	
	\textit{Restart the system} & The process through which the robot is repositioned in a given point A without restarting the software. & Restart\newline Reboot \newline Reboot the system\\
	
	\hline 

\end{tabular}


%===========================================================================
\subsection {User Stories}
%===========================================================================

A \textbf{user story}  is an informal description of one or more features of a software system, and it's expressed in natural language in order to be understandable by anyone. A user story is then described from the end user's point of view, and not from the system's point of view. \newline\newline
The goal of the user stories is to describe with sufficient precision the end user's real needs, then what the user wants from the system, without to express technical details about the analysis, the design and the implementation of the software system. \newline\newline
The user stories will be defined using the following format:

\begin{center}
\textit{"As a \textbf{user}, I want <GOAL> so that <BENEFIT>"}
\end{center}

where \textit{<BENEFIT>} denotes the acceptance criteria that must be respected in the story to ensure a proper implementation of the related features. \newline\newline
The stories collected by analyzing the requirements text are the following.

\begin{enumerate}
	\item As a \textbf{user}, \textbf{I want that} the robot moves from a given point A to area B by travelling along a straight line.
	\item As a \textbf{user}, \textbf{I want that} the robot stops when it reaches the area in front of a sonar and rotates towards it \textbf{so that} it can take a photo of the wall and send it to the console.
	\item As a \textbf{user}, \textbf{I want that} the robot rotates to its original position after it took a photo \textbf{so that} it can continue to move towards the area B.
	\item As a \textbf{user}, \textbf{I want that} an alarm sound is played whether the value calculated through the expression of the distance is under a certain threshold (i.e. a sensor on the wall has detected an obstacle in front of itself).
	\item As a \textbf{user}, \textbf{I want} to use the console in order to send commands to the robot \textbf{so that} I can stop its movements.
	\item As a \textbf{user}, \textbf{I want} to view the sonar data on the GUI.
	\item As a \textbf{user}, \textbf{I want} to see the photos taken and sent by the robot to the console.
	\item As a \textbf{user}, \textbf{I want} to restart the system by manually repositioning the robot at a given point A (i.e. without restarting the software).
\end{enumerate}


%===========================================================================
\subsection {User Interaction}
%===========================================================================

Per rappresentare l’interazione tra agenti esterni e il sistema utilizzeremo diagrammi uml.
L’unico attore è l’utente che interagisce con il sistema attraverso una serie d’azioni/comandi che rappresentano un caso d’uso nel diagramma. Il sistema è composto principalmente dalla console e dal robot. 

NB: caso d’uso solo quello che può far direttamente l’utente, quindi mettere il robot, inviargli i comandi e guardare sul radar la posizione del robot. 
Scenari: Console , il robot,
\\
\begin{tabular}{ | m{5cm} | m{5cm}| }
\hline
	Name&Place Robot\\ 
\hline	
	Descrizione&Piazzare il robot\\
\hline	
	Attori&Utente\\
\hline	
	Precondizioni&La scelta del punto determinerà la traiettoria che poi avrà il robot.\\
\hline	
Scenario principale&L’utente metterà il robot in un punto A. A partire da quel punto il robot potrà iniziare a muoversi.\\
\hline	
Scenari alternativi&---\\
\hline	
Postcondizioni&Il robot deve riavviarsi ogni volta che viene posizionato.\\
\hline
\end{tabular}
\\
\\
\\
\\

\begin{tabular}{ | m{5cm} | m{5cm}| }
	\hline
	Name&Send Command\\ 
	\hline	
	Descrizione&Invio di un comando al sistema da parte dell’utente\\
	\hline	
	Attori&Utente\\
	\hline	
	Precondizioni&La console è attiva e funzionante sul computer e il sistema è pronto a ricevere comandi.\\
	\hline	
	Scenario principale&1. L’utente invia un comando al robot tramite il pannello dei comandi presente sul PC. I comandi inviati sono START per azionare il robot e STOP per fermarlo.
	2. Il server invia il comando al robot.
	3. Il robot valuta il comando e lo esegue.\\
	\hline	
	Scenari alternativi&---\\
	\hline	
	Postcondizioni&Il robot si aziona se riceve il comando START, si ferma se riceve il comando STOP.\\
	\hline
\end{tabular}


\begin{tabular}{ | m{5cm} | m{5cm}| }
	\hline
	Name&View Sonar\\ 
	\hline	
	Descrizione&Visualizzare la posizione del robot sul sonar\\
	\hline	
	Attori&Utente\\
	\hline	
	Precondizioni&La console dovrà funzionare sul pc.\\
	\hline	
	Scenario principale&L’utente potrà vedere il robot nella GUI e si potranno seguire i movimenti.\\
	\hline	
	Scenari alternativi&---\\
	\hline	
	Postcondizioni&Il robot si aziona se riceve il comando START, si ferma se riceve il comando STOP.\\
	\hline
\end{tabular}
\subsection {(Domain) Model }

\subsection {Test Planning}
---TO DO
\section{Problem analysis }

%===========================================================================
%===========================================================================
%===========================================================================
%===========================================================================
%===========================================================================
\subsection{Logic architecture}
---TO DO

\subsection{Risk analysis}
---TO DO
%===========================================================================
\section{Work Plan}
---TO DO

\section{Implementation}
---TO DO
\section{Testing}
---TO DO
\section{Deployment}
---TO DO


%===========================================================================
%===========================================================================
\end{document}
 
