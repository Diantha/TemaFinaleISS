/* 
 * ==============================================================
 * radargui.qa
 * ==============================================================
 */   
System radargui     
Event sonar : p( Distance, Angle  ) 
Event obstacle       : obstacle(X)   //from WebGUI red button X= near or from actor GUI
Event control        : control( CMD )	//CMD = stop | atpos | go | ready
Event usercmd        : usercmd(X)    //from robot-part of WebGUI;  X=robotgui(CMD) CMD=s(low)

Event local_inputcmd : usercmd(X)   //generated by cmd actor gui-interface
Event inputcmd       : usercmd(X) 	//generated by HTTP cmd user-interface
Event alarm          : alarm(X) 	//generated by HTTP cmd user-interface
Event endplay        : endplay(X)   //generated by a user play command
Event numOfSonar : numOfSonar( N )  
Event stopRobot : stopRobot
Event stopAndTakePhoto : stopAndTakePhoto


Dispatch polar    : p( Distance, Angle  )    
Dispatch robotCommand : rc( Command )
Dispatch mqttmsg : mqttmsg
Dispatch robotCommand : rc( Command )


Context  ctxRadar    ip [ host="192.168.251.1"  port=8033 ]  -httpserver //192.168.251.1
//Context  ctxRadar    ip [ host="192.168.251.1"  port=8033 ] -g green -httpserver
Context  ctxSensorEmitter  ip [ host=/*"localhost"*/"192.168.1.103"  port=8133 ] 

/*EventHandler evh for sonar -print  {  //event => dispatch
	forwardEvent radargui -m polar  
	//forwardEvent controltfce16 -m polar
};  */

//EventHandler evh2 for alarm , local_inputcmd , inputcmd, endplay -print {
//	forwardEvent qacmdexecutor -m polar
//} ;
//EventHandler evh for sonar, alarm , local_inputcmd , inputcmd, endplay, numOfSonar -print {
//	forwardEvent qacmdexecutor -m polar //;
////	forwardEvent radargui -m polar
//} ;

QActor radargui context ctxRadar -g green {	  	/*( R2 )*/  
	Plan init normal        
		println("RADAR init the GUI ... ") ;     
		actorOp activateGui ;
		switchToPlan doWorkMsgs      
	Plan doWorkMsgs 
 		println("RADAR receive") ;                      
		receiveMsg time ( 30000000 )  ; 
		//receiveMsg time ( 3000 )  ; 
		printCurrentMessage ;
   		onMsg polar : p(DIST ,SID ) -> actorOp sendDataToGui( DIST,THETA ) ;
   		//onMsg polar : p(DIST ,SID ) -> println (" SHOW DATA ON GUI");  
 		repeatPlan  
 }


QActor controller context ctxRadar -g yellow {
	Plan init normal
	println("Inizio controller ");
	switchToPlan inizio
	
	Plan inizio
	actorOp inizializzazione; //setta tutti i vari parametri valori a 0
	switchToPlan work
	
	Plan work 
	println("Sto aspettando un comando");
	receiveMsg time ( 30000000 ) react event usercmd ->checkCmd ;
	onMsg mqttmsg : mqttmsg -> actorOp retrieveAndSavePhoto ; //per la foto del robot
	onMsg polar : p( Distance , SID ) -> actorOp evaluateExpr; //per i sonar 
	printCurrentMessage ;
	repeatPlan
	
	Plan checkCmd
	[?? actorOpDone (OP ," start ")] switchToPlan inizio ; // se gli ritorna il comando star, ricomincia
	[?? actorOpDone (OP ," stop ")] switchToPlan stopTheRobot ;//stoppa il robot
	[?? actorOpDone (OP ," alarm ")] switchToPlan alarmSound ; //allarme
	resumeLastPlan
	

	Plan stopTheRobot
	println("Stop the robot!!!");
	emit stopRobot: stopRobot ; //manda un messaggio al robot per dire di fermarsi
	resumeLastPlan
	
	Plan alarmSound
	println("An alarm sound is playing !!!");
	sound time (3000) file ("./audio/illogical_most2 .mp3");
	emit stopRobot: stopRobot ; //Il robot, come da requisiti dopo l'allarme si deve fermare
	resumeLastPlan
	
	Plan movoToTakePhoto  
	emit stopAndTakePhoto : stopAndTakePhoto ;
//	forward robot  -m robotCommand :rc( left );
//	forward robot  -m robotCommand :rc( blinkLedStart );
//	forward robot  -m robotCommand :rc( takePhoto );
//	forward robot  -m robotCommand :rc( right );
//	forward robot  -m robotCommand :rc( blinkLedStop );
//	forward robot  -m robotCommand :rc( goForward );
	resumeLastPlan
	
}



QActor sensorsonar context ctxSensorEmitter  -g cyan{    
Rules{
	/* THESE RULES ARE WRITTEN IN THE WorldTheory of the sensorsonar */
	/* CONFIGURATION   */
		onRaspberry.  
		mysonar( s1, coloryellow, /*"localhost"*/"192.168.1.103" ).	 
		//mysonar( s2, colorred, "192.168.251.121" ).		 
		//mysonar( s3, colorgreen, "192.168.251.120" ).	 		
	/* SIMULATION DATA */	   
   		p(80,1).p(70,1).p(60,1).p(50,3).p(40,3).p(30,3).p(20,2).p(40,2).p(60,2).p(80,2).
 	/* RULES */
		sonar(s1,1).
		sonar(s2,2).
 		sonar(s3,3).
		numOfSonars(N) :- bagof(sonar(S,P), sonar(S,P), SonarList), length(SonarList,N).	
		setmyposition  :-  
			numOfSonars(N),
			assert( numSonars( N ) ),
			mysonar( SONAR, _, _ ), sonar(SONAR,SID), 
			assert( position( SID ) ).		
		obstacledata( p(D,SID) ) :- 
			//numSonars( N ),
			actorOpDone( _,d(D) ), 	//set by actorOp getDistanceFromSonar (1)
			position(SID).
	}	  
 	Plan init normal     
 		println("sensorsonar STARTS")  ;
		[ !? onRaspberry ] actorOp startSonarC ;
  		demo setmyposition ;	//depends on mysonar
 		[ !? position(POS) ] println( position(POS) );
 		[ !? numSonars(N) ]  println( numSonars(N) );
 		[ !? numSonars(N) ]  emit numOfSonar : numOfSonar(N) ;
 		switchToPlan workSimulate ;
  		println("sensorsonar workReal")  ;       
  		[ !? onRaspberry ] switchToPlan workReal
 	Plan workSimulate   resumeLastPlan  
  	 	[ !? p(DIST, SID) ] println(p(DIST, SID)) else endPlan  "bye"; 	//p(D,SID) does not work
		[ ?? p(DIST, SID) ] emit sonar : p(DIST,SID) ;
		delay time(500) ;
		repeatPlan 9	 	
	Plan workReal 
		actorOp getDistanceFromSonar ;		//(1)
		[ !? obstacledata( VAL )] println( uuuuu(VAL) ) ;
		[ !? obstacledata( VAL )] emit sonar : VAL ;
//		[ ?? actorOpDone(OP,R )] println(R)	;	//remove actorOpDone
  		repeatPlan
} 



